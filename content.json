{"meta":{"title":"詹平's Blog","subtitle":"","description":"","author":"詹平","url":"https://zhanping.site","root":"/"},"pages":[{"title":"分类","date":"2021-04-19T06:14:39.000Z","updated":"2021-04-19T07:27:53.248Z","comments":false,"path":"categories/index.html","permalink":"https://zhanping.site/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-04-19T06:14:09.000Z","updated":"2021-04-19T06:24:30.425Z","comments":false,"path":"tags/index.html","permalink":"https://zhanping.site/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-04-19T06:15:34.000Z","updated":"2021-04-20T02:51:37.397Z","comments":false,"path":"about/index.html","permalink":"https://zhanping.site/about/index.html","excerpt":"","text":""}],"posts":[{"title":"ThreadLocal内存泄漏问题","slug":"ThreadLocal内存泄漏问题","date":"2021-04-22T08:06:05.000Z","updated":"2021-05-23T05:48:11.000Z","comments":true,"path":"2021/04/22/ThreadLocal内存泄漏问题/","link":"","permalink":"https://zhanping.site/2021/04/22/ThreadLocal%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98/","excerpt":"1.内存泄漏内存溢出: Memory overflow 没有足够的内存提供申请者使用.内存泄漏: Memory Leak 程序中已经动态分配的堆内存由于某种原因, 程序未释放或者无法释放, 造成系统内部的浪费, 导致程序运行速度减缓甚至系统崩溃等严重结果. 内存泄漏的堆积终将导致内存溢出","text":"1.内存泄漏内存溢出: Memory overflow 没有足够的内存提供申请者使用.内存泄漏: Memory Leak 程序中已经动态分配的堆内存由于某种原因, 程序未释放或者无法释放, 造成系统内部的浪费, 导致程序运行速度减缓甚至系统崩溃等严重结果. 内存泄漏的堆积终将导致内存溢出 2. key–&gt;ThreadLocal是强引用假设ThreadLocalMap中的key使用了强引用, 那么会出现内存泄漏吗? 假设在业务代码中使用完ThreadLocal, ThreadLocal ref被回收了 但是因为threadLocalMap的Entry强引用了threadLocal(key就是threadLocal), 造成ThreadLocal无法被回收 在没有手动删除Entry以及CurrentThread(当前线程)依然运行的前提下, 始终有强引用链CurrentThread Ref → CurrentThread →Map(ThreadLocalMap)-&gt; entry, Entry就不会被回收( Entry中包括了ThreadLocal实例和value), 导致Entry内存泄漏 也就是说: ThreadLocalMap中的key使用了强引用, 是无法完全避免内存泄漏的 3. key–&gt;ThreadLocal是弱引用假设ThreadLocalMap中的key使用了弱引用, 那么会出现内存泄漏吗? 假设在业务代码中使用完ThreadLocal, ThreadLocal ref被回收了 由于threadLocalMap只持有ThreadLocal的弱引用, 没有任何强引用指向threadlocal实例（这里Entry不再强引用ThreadLocal了）, 所以threadlocal就可以顺利被gc回收, 此时Entry中的key = null 在没有手动删除Entry以及CurrentThread依然运行的前提下, 也存在始终有强引用链CurrentThread Ref → CurrentThread →Map(ThreadLocalMap)-&gt; entry,value就不会被回收, 而这块value永远不会被访问到了（因为key=null）, 导致value内存泄漏 也就是说: ThreadLocalMap中的key使用了弱引用, 也有可能内存泄漏 4. 内存泄漏的真实原因比较以上两种情况,我们就会发现:内存泄漏的发生跟 ThreadLocalIMap 中的 key 是否使用弱引用是没有关系的。那么内存泄漏的的真正原因是什么呢？ 细心的同学会发现，在以上两种内存泄漏的情况中．都有两个前提：主要两个原因1 . 没有手动侧除这个 Entry2 . CurrentThread 当前线程依然运行 第一点很好理解，只要在使用完下 ThreadLocal ，调用其 remove 方法删除对应的 Entry ，就能避免内存泄漏。 第二点稍微复杂一点，由于ThreadLocalMap 是 Thread 的一个属性，被当前线程所引用，所以ThreadLocalMap的生命周期跟 Thread 一样长。那么在使用完 ThreadLocal 的使用，如果当前Thread 也随之执行结束， ThreadLocalMap 自然也会被 gc 回收，从根源上避免了内存泄漏。 综上， ThreadLocal 内存泄漏的根源是：由于ThreadLocalMap 的生命周期跟 Thread 一样长，如果没有手动删除（remove()方法）对应 key 就会导致内存泄漏． 5. key要使用弱引用**为什么使用弱引用**，根据刚才的分析，我们知道了： 无论 ThreadLocalMap 中的 key 使用哪种类型引用都无法完全避免内存泄漏，跟使用弱引用没有关系。 要避免内存泄漏有两种方式： 1 ．使用完 ThreadLocal ，调用其 remove 方法删除对应的 Entry 2 ．使用完 ThreadLocal ，当前 Thread 也随之运行结束 相对第一种方式，第二种方式显然更不好控制，特别是使用线程池的时候，线程结束是不会销毁的． 也就是说，只要记得在使用完ThreadLocal 及时的调用 remove ，无论 key 是强引用还是弱引用都不会有问题. 那么为什么 key 要用弱引用呢 事实上，在 ThreadLocalMap 中的set/getEntry 方法中，会对 key 为 null（也即是 ThreadLocal 为 null ）进行判断，如果为 null 的话，那么会把 value 置为 null 的． 这就意味着使用完 ThreadLocal , CurrentThread 依然运行的前提下．就算忘记调用 remove 方法，弱引用比强引用可以多一层保障：弱引用的 ThreadLocal 会被回收．对应value在下一次 ThreadLocaIMap 调用 set/get/remove 中的任一方法的时候会被清除，从而避免内存泄漏．","categories":[{"name":"Java","slug":"Java","permalink":"https://zhanping.site/categories/Java/"}],"tags":[{"name":"juc","slug":"juc","permalink":"https://zhanping.site/tags/juc/"}]},{"title":"volatile","slug":"volatile","date":"2015-03-22T06:17:04.000Z","updated":"2021-05-23T06:38:22.000Z","comments":true,"path":"2015/03/22/volatile/","link":"","permalink":"https://zhanping.site/2015/03/22/volatile/","excerpt":"1234567891011121314151617181920212223242526/** * volatile具备可见性 */public class C_0010_Visibility &#123; /*volatile*/ int num = 0; public static void main(String[] args) &#123; C_0010_Visibility c = new C_0010_Visibility(); new Thread(new Runnable() &#123; @Override public void run() &#123; ThreadUtils.sleep(300); c.num = 1; &#125; &#125;).start(); while (c.num == 0) &#123; &#125; System.out.println(&quot;程序结束&quot;); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536/** * volatile不具备原子性 */public class C_0020_Atomicity &#123; volatile int nNum = 0; AtomicInteger aNum = new AtomicInteger(0); public void addNormal() &#123; nNum++; &#125; public void addAtomic() &#123; aNum.getAndIncrement(); &#125; public static void main(String[] args) throws Exception &#123; int threadNum = 20; CountDownLatch latch = new CountDownLatch(threadNum); C_0020_Atomicity c = new C_0020_Atomicity(); for (int i = 0; i &lt; threadNum; i++) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; for (int j = 0; j &lt; 10000; j++) &#123; c.addNormal(); c.addAtomic(); latch.countDown(); &#125; &#125; &#125;).start(); &#125; latch.await(); System.out.println(&quot;nNum:&quot; + c.nNum); System.out.println(&quot;aNum:&quot; + c.aNum); &#125;&#125;","text":"1234567891011121314151617181920212223242526/** * volatile具备可见性 */public class C_0010_Visibility &#123; /*volatile*/ int num = 0; public static void main(String[] args) &#123; C_0010_Visibility c = new C_0010_Visibility(); new Thread(new Runnable() &#123; @Override public void run() &#123; ThreadUtils.sleep(300); c.num = 1; &#125; &#125;).start(); while (c.num == 0) &#123; &#125; System.out.println(&quot;程序结束&quot;); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536/** * volatile不具备原子性 */public class C_0020_Atomicity &#123; volatile int nNum = 0; AtomicInteger aNum = new AtomicInteger(0); public void addNormal() &#123; nNum++; &#125; public void addAtomic() &#123; aNum.getAndIncrement(); &#125; public static void main(String[] args) throws Exception &#123; int threadNum = 20; CountDownLatch latch = new CountDownLatch(threadNum); C_0020_Atomicity c = new C_0020_Atomicity(); for (int i = 0; i &lt; threadNum; i++) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; for (int j = 0; j &lt; 10000; j++) &#123; c.addNormal(); c.addAtomic(); latch.countDown(); &#125; &#125; &#125;).start(); &#125; latch.await(); System.out.println(&quot;nNum:&quot; + c.nNum); System.out.println(&quot;aNum:&quot; + c.aNum); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * volatile具备有序性（禁止指令重排） */public class C_0030_Ordering &#123; /*volatile*/ int x = 0, y = 0, a = 0, b = 0; /** * https://www.jpxzm.com/2020/08/01/volatile为什么能禁止指令重排/ * &lt;p&gt; * 如果没有进行指令重排，那么x与y至少有一个为1； * 如果被指令重排过了，即(x = b在a = 1之前执行) || (y = a在b = 1之前执行)，那么才可能会导致(x=0,y=0) */ public void test() throws Exception &#123; for (int i = 0; ; i++) &#123; x = y = a = b = 0; CountDownLatch latch = new CountDownLatch(2); new Thread(new Runnable() &#123; @Override public void run() &#123; a = 1; x = b; latch.countDown(); &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; b = 1; y = a; latch.countDown(); &#125; &#125;).start(); latch.await(); System.out.println(&quot;第&quot; + i + &quot;次(x=&quot; + x + &quot;,y=&quot; + y + &quot;)&quot;); if (x == 0 &amp;&amp; y == 0) &#123; System.out.println(&quot;竟然出现了x=0，y=0的情况，这种现象只有在x=b这条语句跑到a=1前面，并且y=a跑到b=1前面执行才有可能产生的，这说明CPU给指令进行了重排&quot;); break; &#125; &#125; &#125; public static void main(String[] args) throws Exception &#123; new C_0030_Ordering().test(); &#125;&#125; 12345678910111213141516171819202122232425/** * volatile具备有序性（禁止指令重排） */public class C_0030_Ordering_Singleton_DCL &#123; /** * 一定要加volatile，以防止指令重排造成的线程安全问题 * https://www.bilibili.com/video/BV18b411M7xz?p=11 * https://blog.csdn.net/u013837825/article/details/106004879/ */ private static volatile C_0030_Ordering_Singleton_DCL instance = null; private C_0030_Ordering_Singleton_DCL() &#123;&#125; public static C_0030_Ordering_Singleton_DCL getInstance() &#123; if (instance == null) &#123; synchronized (C_0030_Ordering_Singleton_DCL.class) &#123; if (instance == null) &#123; instance = new C_0030_Ordering_Singleton_DCL(); &#125; &#125; &#125; return instance; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhanping.site/categories/Java/"}],"tags":[{"name":"juc","slug":"juc","permalink":"https://zhanping.site/tags/juc/"}]}],"categories":[{"name":"Java","slug":"Java","permalink":"https://zhanping.site/categories/Java/"}],"tags":[{"name":"juc","slug":"juc","permalink":"https://zhanping.site/tags/juc/"}]}