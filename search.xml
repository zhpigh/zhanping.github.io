<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ThreadLocal内存泄漏问题</title>
    <url>/2021/04/22/ThreadLocal%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="1-内存泄漏"><a href="#1-内存泄漏" class="headerlink" title="1.内存泄漏"></a>1.内存泄漏</h2><p>内存溢出: Memory overflow <strong>没有足够的内存</strong>提供申请者使用.<br><strong>内存泄漏</strong>: Memory Leak 程序中<strong>已经动态分配的堆内存</strong>由于某种原因, <strong>程序未释放或者无法释放, 造成系统内部的浪费</strong>, 导致程序运行速度减缓甚至系统崩溃等严重结果. 内存泄漏的堆积终将导致内存溢出</p>
<h2 id="2-key–-gt-ThreadLocal是强引用"><a href="#2-key–-gt-ThreadLocal是强引用" class="headerlink" title="2. key–&gt;ThreadLocal是强引用"></a>2. key–&gt;ThreadLocal是强引用</h2><p>假设<strong>ThreadLocalMap中的key使用了强引用</strong>, 那么会出现内存泄漏吗?</p>
<p><img src="image-20210127230839634.png" alt="image-20210127230839634"></p>
<ul>
<li>假设在业务代码中使用完ThreadLocal, ThreadLocal ref被回收了</li>
<li>但是因为threadLocalMap的Entry强引用了threadLocal(<strong>key就是threadLocal</strong>), 造成ThreadLocal无法被回收</li>
<li>在没有手动删除Entry以及<strong>CurrentThread(当前线程</strong>)依然运行的前提下, 始终有<code>强引用链CurrentThread Ref → CurrentThread →Map(ThreadLocalMap)-&gt; entry</code>, Entry就不会被回收( Entry中包括了ThreadLocal实例和value), 导致Entry内存泄漏</li>
</ul>
<p>也就是说: ThreadLocalMap中的<code>key使用了强引用, 是无法完全避免内存泄漏的</code></p>
<h2 id="3-key–-gt-ThreadLocal是弱引用"><a href="#3-key–-gt-ThreadLocal是弱引用" class="headerlink" title="3. key–&gt;ThreadLocal是弱引用"></a>3. key–&gt;ThreadLocal是弱引用</h2><p>假设<strong>ThreadLocalMap中的key使用了弱引用</strong>, 那么会出现内存泄漏吗?</p>
<p><img src="image-20210127231220865.png" alt="image-20210127231220865"></p>
<ul>
<li>假设在业务代码中使用完ThreadLocal, ThreadLocal ref被回收了</li>
<li>由于threadLocalMap只<strong>持有ThreadLocal的弱引用</strong>, 没有任何强引用指向threadlocal实例（这里Entry不再强引用ThreadLocal了）, 所以threadlocal就可以顺利被gc回收, 此时Entry中的<strong>key = null</strong></li>
<li>在没有手动删除Entry以及CurrentThread依然运行的前提下, 也存在始终有<code>强引用链CurrentThread Ref → CurrentThread →Map(ThreadLocalMap)-&gt; entry</code>,value就不会被回收, 而这块value永远不会被访问到了（因为key=null）, 导致value内存泄漏</li>
</ul>
<p>也就是说: <code>ThreadLocalMap中的key使用了弱引用, 也有可能内存泄漏</code></p>
<h2 id="4-内存泄漏的真实原因"><a href="#4-内存泄漏的真实原因" class="headerlink" title="4. 内存泄漏的真实原因"></a>4. 内存泄漏的真实原因</h2><p><img src="image-20210127231526640.png" alt="image-20210127231526640"><br>比较以上两种情况,我们就会发现:<br>内存泄漏的发生跟 ThreadLocalIMap 中的 key 是否使用弱引用是没有关系的。那么内存泄漏的的真正原因是什么呢？</p>
<p>细心的同学会发现，在以上两种<strong>内存泄漏的情况</strong>中．都有两个前提：<strong>主要两个原因</strong><br><strong>1 . 没有手动侧除这个 Entry</strong><br><strong>2 . CurrentThread 当前线程依然运行</strong></p>
<ul>
<li>第一点很好理解，只要在使用完下 ThreadLocal ，调用其 remove 方法删除对应的 Entry ，就能避免内存泄漏。</li>
<li>第二点稍微复杂一点，由于ThreadLocalMap 是 Thread 的一个属性，被当前线程所引用，所以ThreadLocalMap的生命周期跟 Thread 一样长。那么在使用完 ThreadLocal 的使用，如果当前Thread 也随之执行结束， ThreadLocalMap 自然也会被 gc 回收，从根源上避免了内存泄漏。</li>
</ul>
<p>综上， ThreadLocal <strong>内存泄漏的根源</strong>是：<br><strong>由于ThreadLocalMap 的生命周期跟 Thread 一样长，如果没有手动删除（remove()方法）对应 key 就会导致内存泄漏．</strong></p>
<h2 id="5-key要使用弱引用"><a href="#5-key要使用弱引用" class="headerlink" title="5. key要使用弱引用"></a>5. key要使用弱引用</h2><p>**<code>为什么使用弱引用</code>**，根据刚才的分析，我们知道了：</p>
<p>无论 ThreadLocalMap 中的 <strong>key 使用哪种类型引用都无法完全避免内存泄漏，跟使用弱引用没有关系。</strong></p>
<p> <strong>要避免内存泄漏有两种方式：</strong></p>
<ul>
<li> 1 ．使用完 ThreadLocal ，调用其 remove 方法删除对应的 Entry</li>
<li> 2 ．使用完 ThreadLocal ，当前 Thread 也随之运行结束</li>
</ul>
<p>相对第一种方式，第二种方式显然更不好控制，特别是使用线程池的时候，线程结束是不会销毁的．</p>
<p>也就是说，只要记得在使用完ThreadLocal 及时的调用 remove ，无论 key 是强引用还是弱引用都不会有问题.</p>
<p><strong><code>那么为什么 key 要用弱引用呢</code></strong></p>
<p>事实上，在 <code>ThreadLocalMap 中的set/getEntry 方法</code>中，会<code>对 key 为 null</code>（也即是 ThreadLocal 为 null ）进行判断，如果为 null 的话，那么<code>会把 value 置为 null 的</code>．</p>
<p> 这就意味着使用完 ThreadLocal , CurrentThread 依然运行的前提下．就算忘记调用 remove 方法，<strong>弱引用比强引用可以多一层保障</strong>：弱引用的 ThreadLocal 会被回收．对应value在下一次 ThreadLocaIMap 调用 set/get/remove 中的任一方法的时候会被清除，从而避免内存泄漏．</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>juc</tag>
      </tags>
  </entry>
  <entry>
    <title>volatile</title>
    <url>/2015/03/22/volatile/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * volatile具备可见性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C_0010_Visibility</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*volatile*/</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        C_0010_Visibility c = <span class="keyword">new</span> C_0010_Visibility();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                ThreadUtils.sleep(<span class="number">300</span>);</span><br><span class="line">                c.num = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (c.num == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;程序结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * volatile不具备原子性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C_0020_Atomicity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> nNum = <span class="number">0</span>;</span><br><span class="line">    AtomicInteger aNum = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNormal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        nNum++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtomic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        aNum.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> threadNum = <span class="number">20</span>;</span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(threadNum);</span><br><span class="line">        C_0020_Atomicity c = <span class="keyword">new</span> C_0020_Atomicity();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadNum; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                        c.addNormal();</span><br><span class="line">                        c.addAtomic();</span><br><span class="line">                        latch.countDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;nNum:&quot;</span> + c.nNum);</span><br><span class="line">        System.out.println(<span class="string">&quot;aNum:&quot;</span> + c.aNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * volatile具备有序性（禁止指令重排）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C_0030_Ordering</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*volatile*/</span> <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * https://www.jpxzm.com/2020/08/01/volatile为什么能禁止指令重排/</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 如果没有进行指令重排，那么x与y至少有一个为1；</span></span><br><span class="line"><span class="comment">     * 如果被指令重排过了，即(x = b在a = 1之前执行) || (y = a在b = 1之前执行)，那么才可能会导致(x=0,y=0)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ; i++) &#123;</span><br><span class="line">            x = y = a = b = <span class="number">0</span>;</span><br><span class="line">            CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    a = <span class="number">1</span>;</span><br><span class="line">                    x = b;</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    b = <span class="number">1</span>;</span><br><span class="line">                    y = a;</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">            latch.await();</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span> + i + <span class="string">&quot;次(x=&quot;</span> + x + <span class="string">&quot;,y=&quot;</span> + y + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;竟然出现了x=0，y=0的情况，这种现象只有在x=b这条语句跑到a=1前面，并且y=a跑到b=1前面执行才有可能产生的，这说明CPU给指令进行了重排&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> C_0030_Ordering().test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * volatile具备有序性（禁止指令重排）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C_0030_Ordering_Singleton_DCL</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一定要加volatile，以防止指令重排造成的线程安全问题</span></span><br><span class="line"><span class="comment">     * https://www.bilibili.com/video/BV18b411M7xz?p=11</span></span><br><span class="line"><span class="comment">     * https://blog.csdn.net/u013837825/article/details/106004879/</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> C_0030_Ordering_Singleton_DCL instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">C_0030_Ordering_Singleton_DCL</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> C_0030_Ordering_Singleton_DCL <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (C_0030_Ordering_Singleton_DCL.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> C_0030_Ordering_Singleton_DCL();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>juc</tag>
      </tags>
  </entry>
</search>
